#ifndef ABSYN_HEADER
#define ABSYN_HEADER

/* C++ Abstract Syntax Interface generated by the BNF Converter.*/

/********************   TypeDef Section    ********************/
typedef int Integer;
typedef char Char;
typedef double Double;
typedef char* String;
typedef char* Ident;


/********************   Forward Declarations    ********************/

struct Prog_;
typedef struct Prog_ *Prog;
struct PrsList_;
typedef struct PrsList_ *PrsList;
struct Pragma_;
typedef struct Pragma_ *Pragma;
struct InstrList_;
typedef struct InstrList_ *InstrList;
struct Instr_;
typedef struct Instr_ *Instr;
struct R_;
typedef struct R_ *R;
struct A_;
typedef struct A_ *A;
struct S_;
typedef struct S_ *S;
struct V_;
typedef struct V_ *V;


/********************   Abstract Syntax Classes    ********************/

struct Prog_
{
  enum { is_Program } kind;
  union
  {
    struct { InstrList instrlist_; PrsList prslist_; } program_;
  } u;
};

Prog make_Program(PrsList p0, InstrList p1);

struct PrsList_
{
  enum { is_PLNone, is_PLElem } kind;
  union
  {
    struct { Pragma pragma_; PrsList prslist_; } plelem_;
  } u;
};

PrsList make_PLNone();
PrsList make_PLElem(Pragma p0, PrsList p1);

struct Pragma_
{
  enum { is_Alloc, is_Set } kind;
  union
  {
    struct { S s_; } alloc_;
    struct { R r_; V v_; } set_;
  } u;
};

Pragma make_Alloc(S p0);
Pragma make_Set(R p0, V p1);

struct InstrList_
{
  enum { is_ILNone, is_ILElem } kind;
  union
  {
    struct { Instr instr_; InstrList instrlist_; } ilelem_;
  } u;
};

InstrList make_ILNone();
InstrList make_ILElem(Instr p0, InstrList p1);

struct Instr_
{
  enum { is_Inc, is_Dec } kind;
  union
  {
    struct { R r_; } inc_;
    struct { A a_; R r_; } dec_;
  } u;
};

Instr make_Inc(R p0);
Instr make_Dec(R p0, A p1);

struct R_
{
  enum { is_Reg } kind;
  union
  {
    struct { Integer integer_; } reg_;
  } u;
};

R make_Reg(Integer p0);

struct A_
{
  enum { is_Addr } kind;
  union
  {
    struct { Integer integer_; } addr_;
  } u;
};

A make_Addr(Integer p0);

struct S_
{
  enum { is_Size } kind;
  union
  {
    struct { Integer integer_; } size_;
  } u;
};

S make_Size(Integer p0);

struct V_
{
  enum { is_Value } kind;
  union
  {
    struct { Integer integer_; } value_;
  } u;
};

V make_Value(Integer p0);



#endif
